"""module for Data Process in ML fall2015 final project"""
__author__ = "jinlong Frank Feng"



import numpy as np
import wave as wv
import os
from features import mfcc
from features import logfbank
from features import fbank
import scipy.io.wavfile as wav

from pylab import*


def debug(variable, varnamestr):
	print "Varname: " +  varnamestr  
	print "Type: " + str(type(variable))
	if type(variable) == 'numpy.ndarray':
		print "Length: " + str(variable.shape)
	else:
		print "Length: " + str(len(variable))
	print "Content: "
	if type(variable) == 'dict':
		for i in variable:
			print i
			print variable[i]
	else:
		print variable
	print " "
	return



def fdebug(variable, varnamestr):
	# readLabel.debug(self, variable, varnamestr)
	filename = varnamestr + ".dtxt"
	debuglog = open(filename, 'a')
	debuglog.write( "Varname: " +  varnamestr  + '\n')
	debuglog.write( "Type: " + str(type(variable)) + '\n')
	if type(variable) == 'numpy.ndarray':
		debuglog.write( "Length: " + str(variable.shape) + '\n')
	else:
		debuglog.write( "Length: " + str(len(variable)) + '\n')
	debuglog.write( "Content: " + '\n')

	if type(variable) == dict:
		for i in variable:
			print i
			print variable[i]
			debuglog.write(str(i) + ': \n')
			debuglog.write(str(variable[i]) + '\n')
		debuglog.write( " " + '\n')
	else:
		for i in variable:
			print i
			debuglog.write(str(i) + '\n')
		debuglog.write( " " + '\n')
	debuglog.close()

	return

def merge_two_dicts(x, y):
    z = x.copy()
    z.update(y)
    return z


class instances: # the class of a analyzed sentence


	def __init__(self):
		self.FileName = None # corresponding filename, which is a unique single name refering to a sentence, without .type. the related file could be .wav or .txt. 
		self.trainingLabel = None # the training label. which is just one emotion judgement generated by voting. For training purpose
		self.testLabel = [] # the label for accuracy test, could be a top x judgement.
		self.featureVec = [] # the composite feature vector for this instance, for training use
		# currently the structure of featureVec is :
		# 3-tuple(vad) + 12-tuple(mfcc) + 12-tuple(fbank) + TBC
		return
	def setValue(self, name, trainL, testL, Vec):
		self.FileName = name
		self.trainingLabel = trainL
		self.testLabel = testL
		self.featureVec = Vec
		return

	def copy(self, instances):
		self.setValue(instances.FileName, instances.trainL, instances.testL, instances.Vec)
		return

	def display(self): # show it self
		print self.FileName
		print self.trainingLabel
		print self.testLabel
		print self.featureVec
		return



class readAudio: # the class to read an audio file

	def __init__(self, audioPath = None):
		if audioPath != None:
			self.filePath = audioPath
		return


	def readFile(self, audioPath):
		self.filePath = audioPath

		return

	def featureDicGen(self, rangeStart, rangeEnd): # generate the dictionary of all instances as the key and their audio feature vector as value
	
		rootDir1 = "Session"
		featureDic = {}
		tempDiclist = [] # the list for append the tempfeatDic, after all calculations, add them into featureDic


		for i in range(rangeStart, rangeEnd):
			dir1 = rootDir1 + str(i)
			dir1 = os.path.join(dir1, "sentences")
			dir1 = os.path.join(dir1, "wav")
			for dir2 in os.listdir(dir1):
				dir3 = os.path.join(dir1, dir2)
				print dir3
				tempfeatDic = readAudio.dicGen(self, dir3)
				tempDiclist.append(tempfeatDic)

		

		for subDic in tempDiclist:
			for key in subDic:
				featureDic[key] = subDic[key]
		# fdebug(featureDic, "featureDic")

		return featureDic

	def dicGen(self, audioPath): # the sub routine in featureDicGen
		

		featureDic = {}
		# count = 0 # for test
		for item in os.listdir(audioPath):
			# count += 1

			# if count > 4:
			# 	break
			# debug(item,"item")
			if item[-4:] != ".wav":
				continue


			tempVec = [] # the feature vector of current clip being processed

			wavepath = os.path.join(audioPath, item)
			print "processing " + wavepath
			rate, sig = wav.read(wavepath)
			
			mfcc_feat = mfcc(sig,rate)
			# debug(mfcc_feat, "mfcc_feat")
			# debug(mfcc_feat[0], "mfcc_feat[0]")
			# break


			delta_mfcc = readAudio.deltacal(self, mfcc_feat)
			# debug(delta_mfcc, "delta_mfcc")
			# debug(delta_mfcc[0], "delta_mfcc[0]")
			# break


			deltadelta_mfcc = readAudio.deltadelta(self, delta_mfcc)
			# debug(deltadelta_mfcc, "deltadelta_mfcc")


			mfcc_feat = np.mean(mfcc_feat[:, 1:13], axis = 0)
			delta_mfcc = np.mean(delta_mfcc, axis = 0)
			deltadelta_mfcc = np.mean(deltadelta_mfcc, axis = 0)

			# take means of all windows in each dim for mfcc, delta_mfcc and deltadelta_mfcc


			fbank_feat, energy = fbank(sig,rate)
			# debug(energy, "energy")

			fbank_feat = np.mean(fbank_feat[:, 1:13], axis = 0)

			# debug(energy, "energy")
			
			energy_vec = []
			energyarray = np.asarray(energy)
			energy_vec.append(np.mean(energyarray, axis = 0))
			energy_vec.append(np.median(energyarray, axis = 0))
			energy_vec.append(np.std(energyarray, axis = 0))
			energy_vec.append(np.amax(energyarray, axis = 0))
			energy_vec.append(np.amin(energyarray, axis = 0))
			energy_vec = np.asarray(energy_vec)

			# debug(energy_vec, "test")

			# take the mean, dedian, standard diviation, max and min of the energy, 5 dim in all, into the feature vector

			# print len(delta_mfcc)
			tempVec.extend(mfcc_feat) # 12
			# tempVec.extend(delta_mfcc)
			# tempVec.extend(deltadelta_mfcc)
			tempVec.append(delta_mfcc) # 1 need to fix
			tempVec.append(deltadelta_mfcc) # 1 need to fix
			tempVec.extend(fbank_feat) # 12
			tempVec.extend(energy_vec) # 5

			clip_name = item.split('.')[0] # name of the clip, as the key in the dictionary

			featureDic[clip_name] = tempVec
			# print len(tempVec)

			
			# break

		return featureDic

	#----------------------------------------------------------
	# the following functions in this class is from zhangzhang liu
	# delta is the approximate of 1 order derivitive

	def deltacal(self, win12array, N = 2):
	    n = np.arange(-N, N + 1)
	    denominate = sum(n**2)
	    numerator = [sum([win12array[j+i]*i for i in n]) for j in range(N,len(win12array) - N)]
	    debug(numerator, "numerator")
	    # numerator = [[win12array[j+i]*i for i in n] for j in range(N,len(win12array) - N)]
	    return numerator/denominate
	    
	# second order
	def deltadelta(self, delta12array, N = 2):
	    return readAudio.deltacal(self, delta12array, N = 2)



class readLabel: # the class to read a label file

	def __init__(self, labelPath = None):
		self.filePath = labelPath
		return


	def readFile(self, labelPath = None): # read in a emotion evaluation file and return the filenames and the corresponding labels
		if labelPath != None:
			self.filePath = labelPath
		else:
			labelPath = self.filePath

		inputfile = open(self.filePath)

		instanceVec = []

		# filenames = [] # 1D vector of filenames
		
		# labelMatrix = [] # label matrix, a list of ndarrays
		# VADMatrix = [] # VAD matrix a list of ndarrays

		# nameBegin = True # the begin indicator of the parsing of filenames

		# catLabel = []
		# # the entries in catLabel are :
		# # 0: ground truth
		# # middle part: evaluator category evaluations
		# # -1: actor category evaluation

		# VADLabel = []

		# # 1D vector of VAD values : val, act, dom
		# # 0 - 2 : ground truth
		# # middle part : VAD evaluation of evaluators (all in 3 -tuples)
		# # -3 - -1: actor VAD evaluation
		# print labelPath
		count = -1
		while(1):

			

			tempstring = inputfile.readline()
			if not tempstring:
				# if len(catLabel): # push the last instance of the file into matrix
				# 	labelMatrix.append(catLabel)
				# if len(VADLabel):
				# 	VADMatrix.append(VADLabel)
				break
			
			tempstring = tempstring.strip()

			if not len(tempstring):
				continue

			

			
			#------------------first version of matrix building (start)
			
			# if tempstring[0] == '[': # indicate the start of a new instance. read in the filename and the ground truth category label

			# 	tempstring = tempstring.split('\t')

			# # push the category label vector of previous instance into the matrix
			# 	if len(catLabel):
			# 		labelMatrix.append(catLabel)
			# 	if len(VADLabel):
			# 		VADMatrix.append(VADLabel)

			# 	if nameBegin:
			# 		filenames = np.asarray(tempstring[1])
			# 		nameBegin = False
			# 	else:
			# 		filenames = np.hstack((filenames, np.asarray(tempstring[1])))
			# 		# print 1
			# 		# print filenames
			# 	# print catLabel
			# 	catLabel = np.asarray(tempstring[2])
			# 	# print 2
			# 	# print catLabel

			# 	vadParse = tempstring[3].strip('[')
			# 	vadParse = vadParse.strip(']')
			# 	vadParse = vadParse.split(', ')
			# 	# print vadParse

			# 	VADLabel = np.asarray(float(vadParse[0]))
			# 	# print VADLabel
			# 	VADLabel = np.hstack((VADLabel, np.asarray(float(vadParse[1]))))
			# 	# print VADLabel
			# 	VADLabel = np.hstack((VADLabel, np.asarray(float(vadParse[2]))))
			# 	# print VADLabel

			#------------------first version of matrix building(end)
			if tempstring[0] == '[': # indicate the start of a new instance. read in the filename and the ground truth category label
				count += 1

				tempInstance = instances()

				tempstring = tempstring.split('\t')

				tempInstance.FileName = tempstring[1]
				
				tempInstance.trainingLabel = tempstring[2]

				vadParse = tempstring[3].strip('[')
				vadParse = vadParse.strip(']')
				vadParse = vadParse.split(', ')
				# print vadParse
				# vadParse = vadParse.astype(np.float)
				# vadParse = float(vadParse)
				# for item in vadParse:
				# for idx in range(len(vadParse)):
					# vadParse[i] = float(vadParse[i]
				# map(float, vadParse)
				vadParse = [float(item) for item in vadParse] # the mean vad value from evaluators
				for item in vadParse:
					tempInstance.featureVec.append(item)

				instanceVec.append(tempInstance)




			else:
				if tempstring[0] == 'C': # A category label
					tempstring = tempstring.split('\t')
					tempCate = tempstring[1].split(' ')
					for cate in tempCate:
						cate = cate.strip(';')
						instanceVec[count].testLabel.append(cate)

				# actor's self vad evaluation is not added in this version

				# if tempstring[0] == 'A-M' or tempstring[0] == 'A-F': # A VAD label
				# 	tempstring = tempstring.split('\t')
				# 	tempCate = tempstring[1].split(' ')
				# 	# print tempCate[6]
				# 	for i in (1,3,-1):
				# 		if tempCate[i].strip(';').strip().isdigit():
				# 			VADLabel = np.hstack((VADLabel, float(tempCate[i].strip(';').strip())))
				# 		else:
				# 			VADLabel = np.hstack((VADLabel, -1))


			# readLabel.debug(self, VADLabel, "VADLabel")

			# elif labelMatrixBegin:
			# 	labelMatrix = catLabel
			# 	labelMatrixBegin = False

		inputfile.close()


		# labelMatrix = np.asarray(labelMatrix)
		# VADMatrix = np.asarray(VADMatrix)

		# return filenames, labelMatrix, VADMatrix
		return instanceVec

	def labelVectorGen(self, rangeStart, rangeEnd):

		rootDir1 = "Session"
		# Rdata = readLabel()
		gcount = 0

		FullInsVec = []

		for i in range(rangeStart, rangeEnd):
		# for i in range(1, 2):
			# fileNames = [] # fileNames of current session
			# fileLabels = [] # fileLabels of current session
			# vadLabels = [] # vadLabels of current session
			dir1 = rootDir1 + str(i)
			dir1 = os.path.join(dir1, "dialog")
			dir1 = os.path.join(dir1, "EmoEvaluation")
			count = 0
			for files in os.listdir(dir1):
				fullpath = os.path.join(dir1, files)
				if os.path.isfile(fullpath):
					
					# tempInsVec = Rdata.readFile(fullpath)
					tempInsVec = readLabel.readFile(self, fullpath)
					FullInsVec.extend(tempInsVec)
		return FullInsVec

	def insVec2Dic(self, insVec):
		insDic = {}
		for item in insVec:
			insDic[item.FileName] = item
		return insDic

	def saveToFile(self, fileNames, catLabels, vadLabels, targetFileName):
		namefile = open(targetFileName[0], 'a')
		catfile = open(targetFileName[1], 'a')
 		vadfile = open(targetFileName[2], 'a')
		num = len(fileNames)
		for i in range(num):
			# write names
			temp = str(fileNames[i]) + '\n'
			namefile.write(temp)
			# write category
			for p in catLabels[i]:
				temp = str(p) + '\t'
				catfile.write(temp)
			catfile.write('\n')
			# write vad
		
			for p in vadLabels[i]:
				temp = str(p) + '\t'
				vadfile.write(temp)
			# vadfile.write(str(vadLabels[i]))
			vadfile.write('\n')

		namefile.close()	
		catfile.close()	
		vadfile.close()			
		return






if __name__ == "__main__":
	

	labels = readLabel()

	InstanceVec = labels.labelVectorGen(1, 2)
	# print type(InstanceVec)
	InstanceDic = labels.insVec2Dic(InstanceVec)
	# print len(InstanceDic)
	# for item in InstanceDic:
	# 	InstanceDic[item].display()


	audios = readAudio()
	featureVecDic = audios.featureDicGen(1, 2)



	print len(InstanceDic)
	print len(featureVecDic)

	# for item in InstanceDic:
	# 	# print item
	# 	InstanceDic[item].featureVec.extend(featureVecDic[item])

	# for item in InstanceDic:
	# 	InstanceDic[item].display()







	# fdebug(featureVec,"featureVec")
	
	# path = os.path.join(path, "sentences")

	# for item in os.listdir(path):
	# 	wavepath = os.path.join(path, item)
	# 	rate, sig = wav.read(wavepath)
	# 	# output.write(str((float(len(b))/float(a))))
	# 	# output.write(str(a))
	# 	# output.write('\n')
	# 	# output.write(str(len(b)))
	# 	# output.write(str(b))
	# 	# output.write('\n')
	# 	mfcc_feat = mfcc(sig,rate)
	# 	fbank_feat = logfbank(sig,rate) 
	# 	# print mfcc_feat


	# 	# for item in fbank_feat:
	# 	# # for item in 
	# 	# 	print item
	# 	# 	break
	# 	print fbank_feat[0]
	# 	print mfcc_feat[0]
	# 	# for item in mfcc_feat:
	# 	# 	print item
	# 		# output.write(item)
	# 	# output.write(fbank_feat)
	# 	# print len(fbank_feat)
	# 	break
	# 	# print len(mfcc_feat)


		# temp = wv.open(wavepath, 'r')
		# print temp.getparams()
		# print temp.readframes(1000)

	# 	break
	# wavepath = os.path.join(path, item)
	# a, b = wavfile.read(path)
	# print a
	# print b


